## Module 4 Lesson 4
### Advanced REST API
(This document is optimized for presentation using [reveal-md](https://github.com/webpro/reveal-md))

---

### Agenda
* Overview
* Dilemmas and Solutions
* Some tips
* Open API And Swagger

---

### Overview
What we know so far
* REST is an **Architectural style** (not a Protocol / Language)
<!-- .element: class="fragment" -->
* REST API provide endpoints to request **Resources**
<!-- .element: class="fragment" -->
* GET `/posts/1` - get entity (identifier is 1)
<!-- .element: class="fragment" -->
* POST `/posts` - create entity (identifier generated by server)
<!-- .element: class="fragment" -->
* PUT `/posts/1` - update entity (complete replacement of entity)
<!-- .element: class="fragment" -->
* PATCH `/posts/1` - update entity (make changes to entity)
<!-- .element: class="fragment" -->
* DELETE `/posts/1` - delete entity


### Overview
What we know so far
* Client-server architecture
<!-- .element: class="fragment" -->
* Statelessness
<!-- .element: class="fragment" -->
* Caching
<!-- .element: class="fragment" -->

---

### Dilemmas and Solutions
But... This standard does not specify EVERYTHING!

What are the questions you dealt with? (Open discussion)
<!-- .element: class="fragment" -->

---

### Dilemmas and Solutions
We'll try to answer a few questions:

1. How to name endpoints?
2. When to use url route / query params?
3. How to manage different API versions?

Note: these are not rules but opinionated guidelines
<!-- .element: class="fragment" -->

---

### Dilemmas and Solutions
1. How to name endpoints?

* If endpoint can return multiple values - it should named with plural form (`/posts`, `/comments`)
<!-- .element: class="fragment" -->
* Avoid multiple endpoints for same entity (Like: `/users` and `/user`)
<!-- .element: class="fragment" -->
* If multiple endpoints for same entity is a must, make it distinctive (Like: `/allUsers` and  `/user`)
<!-- .element: class="fragment" -->
* Use short and self explanatory names
<!-- .element: class="fragment" -->
* use camelCasing
<!-- .element: class="fragment" -->
* Most important of all: be consistent

---

### Dilemmas and Solutions
2. when to use url route / query params?

* `/posts/1` vs  `/posts?id=1`
<!-- .element: class="fragment" -->
* `/posts/danny` vs  `/posts?user=danny`
<!-- .element: class="fragment" -->
* `/posts/1` vs  `/posts?userId=1`
<!-- .element: class="fragment" -->
* `/posts/1/comments/1` vs  `/posts/1?commentId=1`
<!-- .element: class="fragment" -->

Rule of thumb #1:  self - contained data should be an entity (like `comments`)
<!-- .element: class="fragment" -->

Rule of thumb #2:  unique identifier may have it's own url (`/posts/1`)
<!-- .element: class="fragment" -->

---

### Dilemmas and Solutions
3. How to manage different API versions?

* Option 1 - as query parameter: `/posts/1?version=2`
<!-- .element: class="fragment" -->
* Option 2 - as part of the url parameter: `/v2/posts/1`
<!-- .element: class="fragment" -->
* Option 3 - as HTTP header
<!-- .element: class="fragment" -->

Tip: use options 2 or 3. option 2 is easier to debug and recognize
<!-- .element: class="fragment" -->
Rule of thumb: When version is omitted, latest version should be used
<!-- .element: class="fragment" -->

---

### Some tips

* Always document your API, even when working alone
<!-- .element: class="fragment" -->
* When documenting your API, Think about reading it 6 months from now
<!-- .element: class="fragment" -->
* When API changes - so it's documentation 
<!-- .element: class="fragment" -->
* Good API should be intuitive and self explanatory (which end with minimal documentation)
<!-- .element: class="fragment" -->
* Well defined API allow server / client teams work in parallel
<!-- .element: class="fragment" -->
* When work in parallel - use mock API. This way both parties can see the actual responses, and client team can code even if server is not ready
<!-- .element: class="fragment" -->


---

### [Open API And Swagger](https://swagger.io/docs/specification/about/)

* OpenAPI Specification (formerly Swagger Specification) is an API description format for REST APIs.
<!-- .element: class="fragment" -->
* Swagger is a set of open-source tools built around the OpenAPI Specification that can help you design, build, document and consume REST APIs
<!-- .element: class="fragment" -->
* Swagger can provide both documentation and mock
<!-- .element: class="fragment" -->
* <!-- .element: class="fragment" -->[Swagger Editor overview](https://editor.swagger.io/)
* <!-- .element: class="fragment" -->[Swagger tools](https://swagger.io/blog/api-strategy/difference-between-swagger-and-openapi/)


---

### [Open API And Swagger](https://swagger.io/docs/specification/about/)
Getting started
1. Sign up for Swagger hub (can login with github)
2. Create new
3. Edit YAML
4. Save and start writing code

[Open API specification](https://swagger.io/specification/#responsesObject)
[swagger adding -examples](https://swagger.io/docs/specification/adding-examples/)


---

### [Open API And Swagger](https://swagger.io/docs/specification/about/)
Practice: Create API (work in pairs)

Goal: write an app to display data in graph (Climate change over the years)
* Use Swagger to write API, then write client and server in parallel.
* API is not require to look like original data structure - design it according to your needs
[Climate Data](https://github.com/jdorfman/awesome-json-datasets#climate)

---

### Further reading
* [Open API 3.0 vs Swagger 2.0](https://medium.com/@tgtshanika/open-api-3-0-vs-swagger-2-0-94a80f121022)

---

### Home Work:
* Finish class practice

### Extra
* [TSOA](https://github.com/lukeautry/tsoa#goal)
* [Implement Swagger and tsoa to an existing Node application](https://medium.com/@ahmedkhalilbejaoui/implement-swagger-and-tsoa-to-an-existing-node-application-using-webpack-and-pm2-12512d32a504)
